/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-TWAIN.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : TWAIN
 #	author : miyako
 #	2019/09/26
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-TWAIN.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- TWAIN
            
			case 1 :
				TWAIN_Get_devices(params);
				break;
			case 2 :
				TWAIN_Get_default_option(params);
				break;
			case 3 :
				TWAIN_SCAN(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void twain_generate_uuid_pair(std::wstring& ParamA, std::wstring& ParamB) {
    
#if VERSIONWIN
    UUID uuid;
    RPC_WSTR flagPtr;
    if(UuidCreate(&uuid) == RPC_S_OK)
    {
        if(UuidToString(&uuid, &flagPtr) == RPC_S_OK)
        {
            ParamA = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
            RpcStringFree(&flagPtr);
            if(UuidCreate(&uuid) == RPC_S_OK)
            {
                if(UuidToString(&uuid, &flagPtr) == RPC_S_OK)
                {
                    ParamB = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
                    RpcStringFree(&flagPtr);
                }
            }
        }
    }
#endif
}

void twain_get_version_info(TW_UINT16 *MajorNum,
                            TW_UINT16 *MinorNum,
                            TW_UINT16 *Language,
                            TW_UINT16 *Country) {

    PA_ulong32 version = PA_Get4DVersion/*ThreadSafe*/();
    
    *MajorNum = (version & 0x0000FF00) >> 8;
    *MinorNum = (version & 0x000000FF);
    *Language = TWLG_ENGLISH;
    *Country = TWCY_USA;
}

#pragma mark Threads

#if VERSIONWIN

HANDLE createFmIn1(C_TEXT& Param1_scanner, CUTF8String& option,
                   std::wstring& ParamA,
                   std::wstring& ParamB,
                   DWORD *ParamA_len,
                   DWORD *ParamB_len,
                   DWORD *Param1_len,
                   DWORD *Param2_len)
{
    CUTF8String scanner;
    Param1_scanner.copyUTF8String(&scanner);
    
    *ParamA_len = ParamA.length() * sizeof(wchar_t);
    *ParamB_len = ParamB.length() * sizeof(wchar_t);
    *Param1_len = scanner.length();
    *Param2_len = option.length();
    
    DWORD len = (sizeof(DWORD)*4)
    + (*ParamA_len) + (*ParamB_len)
    + (*Param1_len) + (*Param2_len);
    
    BOOL success = FALSE;
    
    HANDLE fmIn = CreateFileMapping(
                                    INVALID_HANDLE_VALUE,
                                    NULL,
                                    PAGE_READWRITE,
                                    0, len,
                                    L"TWAIN_PARAM_IN");
    if(fmIn)
    {
        LPVOID bufIn = MapViewOfFile(fmIn,
                                     FILE_MAP_WRITE,
                                     0,
                                     0, len);
        if(bufIn)
        {
            try
            {
                unsigned char *p = (unsigned char *)bufIn;
                
                CopyMemory(p, ParamA_len, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(p, ParamB_len, sizeof(DWORD));
                p += sizeof(DWORD);
                
                CopyMemory(p, Param1_len, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(p, Param2_len, sizeof(DWORD));
                p += sizeof(DWORD);
                
                CopyMemory(p, ParamA.c_str(), *ParamA_len);
                p += (*ParamA_len);
                CopyMemory(p, ParamB.c_str(), *ParamB_len);
                p += (*ParamB_len);
                
                CopyMemory(p, scanner.c_str(), *Param1_len);
                p += (*Param1_len);
                CopyMemory(p, option.c_str(), *Param2_len);
                
                success = TRUE;
            }
            catch(...)
            {
                /* CopyMemory() failed */
            }
            UnmapViewOfFile(bufIn);
        }//bufIn
        if(!success)
        {
            CloseHandle(fmIn);
            return 0;
        }
        
    }
    
    return fmIn;
}

HANDLE createFmIn2(DWORD *ParamA_len,
                   DWORD *ParamB_len,
                   DWORD *Param1_len,
                   DWORD *Param2_len)
{
    /*
     * Param1:scanner
     * Param2:data
     */
    
    BOOL success = FALSE;
    
    *ParamA_len = 0;
    *ParamB_len = 0;
    *Param1_len = 0;
    *Param2_len = 0;
    
    DWORD len = (sizeof(DWORD)*4);
    
    HANDLE fmIn = CreateFileMapping(
                                    INVALID_HANDLE_VALUE,
                                    NULL,
                                    PAGE_READWRITE,
                                    0, len,
                                    L"TWAIN_PARAM_IN");
    if (fmIn)
    {
        LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
        if (bufIn)
        {
            unsigned char *p = (unsigned char *)bufIn;
            try
            {
                CopyMemory(ParamA_len, p, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(ParamB_len, p, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(Param1_len, p, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(Param2_len, p, sizeof(DWORD));
                
                success = TRUE;
            }
            catch (...)
            {
                
            }
            UnmapViewOfFile(bufIn);
        }//bufIn
        CloseHandle(fmIn);
    }//fmIn
    
    if (success)
    {
        return CreateFileMapping(
                                 INVALID_HANDLE_VALUE,
                                 NULL,
                                 PAGE_READWRITE,
                                 0, len,
                                 L"TWAIN_PARAM_IN");
    }
    
    return 0;
}

HANDLE createEventforBufIn2(LPVOID bufIn,
                            DWORD ParamA_len,
                            DWORD ParamB_len,
                            DWORD Param1_len,
                            DWORD Param2_len,
                            std::wstring& ParamA,
                            std::wstring& ParamB,
                            C_TEXT& Param1_scanner,
	CUTF8String& Param2_option)
{
    unsigned char *p = (unsigned char *)bufIn;
    p = p + (sizeof(DWORD)*4);
    
    std::vector<uint8_t>scanner(Param1_len);
    std::vector<uint8_t>option(Param2_len);
    
    std::vector<uint8_t>signalA(ParamA_len);
    std::vector<uint8_t>signalB(ParamB_len);
    
    if (ParamA_len)
    {
        CopyMemory(&signalA[0], p, ParamA_len);
        p += ParamA_len;
        ParamA = std::wstring((const wchar_t *)&signalA[0], ParamA_len / sizeof(wchar_t));
    }
    
    if (ParamB_len)
    {
        CopyMemory(&signalB[0], p, ParamB_len);
        p += ParamB_len;
        ParamB = std::wstring((const wchar_t *)&signalB[0], ParamB_len / sizeof(wchar_t));
    }
    
    if (Param1_len)
    {
        CopyMemory(&scanner[0], p, Param1_len);
        p += Param1_len;
        Param1_scanner.setUTF8String((const uint8_t *)&scanner[0], Param1_len);
    }
    
    if (Param2_len)
    {
        CopyMemory(&option[0], p, Param2_len);
        p += Param2_len;
		Param2_option = CUTF8String((const uint8_t *)&scanner[0], Param1_len);
    }
    
    HANDLE scanEvent_c = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
                                     TRUE, /* manual-reset event object */
                                     FALSE, /* initial state */
                                     ParamB.c_str());
    
    return scanEvent_c;
}

HANDLE createFmOut2(std::vector<uint8_t>& data)
{
    DWORD data_len = data.size();
    
    DWORD len = sizeof(DWORD) + data_len;
    
    HANDLE fmOut = CreateFileMapping(
                                     INVALID_HANDLE_VALUE,
                                     NULL,
                                     PAGE_READWRITE,
                                     0, len,
                                     L"TWAIN_PARAM_OUT");
    if (fmOut)
    {
        LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_WRITE, 0, 0, len);
        if (bufOut)
        {
            unsigned char *p = (unsigned char *)bufOut;
            try
            {
                CopyMemory(p, &data_len, sizeof(DWORD));
                p += sizeof(DWORD);
                if (data_len)
                {
                    CopyMemory(p, (void *)&data[0], data_len);
                }
            }
            catch (...)
            {
                
            }
            UnmapViewOfFile(bufOut);
        }//bufOut
        
    }
    
    return fmOut;
}

void getDataFromThread2(std::vector<uint8_t>& data)
{
    DWORD data_len = 0;
    DWORD len = sizeof(DWORD);
    
    BOOL success = FALSE;
    
    HANDLE fmOut = CreateFileMapping(
                                     INVALID_HANDLE_VALUE,
                                     NULL,
                                     PAGE_READWRITE,
                                     0, len,
                                     L"TWAIN_PARAM_OUT");
    if (fmOut)
    {
        LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
        if (bufOut)
        {
            unsigned char *p = (unsigned char *)bufOut;
            try
            {
                CopyMemory(&data_len, p, sizeof(DWORD));
                success = TRUE;
            }
            catch (...)
            {
                
            }
            UnmapViewOfFile(bufOut);
        }
        CloseHandle(fmOut);
    }
    if ((success) && (data_len))
    {
        len = len + data_len;
        
        fmOut = CreateFileMapping(
                                  INVALID_HANDLE_VALUE,
                                  NULL,
                                  PAGE_READWRITE,
                                  0, len,
                                  L"TWAIN_PARAM_OUT");
        if (fmOut)
        {
            LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
            if (bufOut)
            {
                unsigned char *p = (unsigned char *)bufOut;
                p = p + sizeof(DWORD);
                try
                {
					data.resize(data_len);
                    CopyMemory((void *)&data[0], p, data_len);
                }
                catch (...)
                {
                    
                }
                UnmapViewOfFile(bufOut);
            }
            CloseHandle(fmOut);
        }
        
    }
    
}

void waitForEvent(HANDLE h, HANDLE scanEvent_p, std::vector<uint8_t>& data, std::wstring& ParamB, DWORD len)
{
    BOOL exit = FALSE;
    do {
        switch (WaitForSingleObject(scanEvent_p, 100))
        {
            case WAIT_ABANDONED:
            case WAIT_FAILED:
                exit = TRUE;
                break;
            case WAIT_TIMEOUT:
                PA_YieldAbsolute();
                break;
            case WAIT_OBJECT_0:
                ResetEvent(scanEvent_p);
                BOOL success = FALSE;
                
                getDataFromThread2(data);
                
                HANDLE scanEvent_c = OpenEvent(EVENT_ALL_ACCESS, FALSE, ParamB.c_str());
                if(scanEvent_c)
                {
                    /* tell c to die */
                    SetEvent(scanEvent_c);
                    CloseHandle(scanEvent_c);
                }
                
                do {
                    switch (WaitForSingleObject(h, 100))
                    {
                        case WAIT_TIMEOUT:
                            PA_YieldAbsolute();
                            break;
                        case WAIT_ABANDONED:
                        case WAIT_FAILED:
                        case WAIT_OBJECT_0:
                            exit = TRUE;
                            break;
                    }
                } while (!exit);
                
                exit = TRUE;
                break;
        }
        
    } while (!exit);
}

#endif

#pragma mark -

void TWAIN_Get_devices(PA_PluginParameters params) {

    PA_CollectionRef devices = PA_CreateCollection();
    
    TW_IDENTITY tw_identity;
    TW_USERINTERFACE tw_userinterface;
    HWND tw_parent = NULL;
    
#if USE_TWAIN_DSM
    TW_ENTRYPOINT tw_entrypoint;
#else
    void *tw_entrypoint;
#endif
    
    TW_UINT16 majorNum, minorNum, language, country;
    twain_get_version_info(&majorNum, &minorNum, &language, &country);
    twain_configure(&tw_identity,
                    &tw_userinterface,
                    &tw_entrypoint,
                    &tw_parent,
                    majorNum, minorNum, language, country);
    TW_UINT16 tw_ret = twain_dsm_open(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent);

    if(tw_ret == TWRC_SUCCESS)
    {
        std::vector<TW_IDENTITY>sources;
        
        twain_get_sources_list(&tw_identity, sources);
        
        PA_long32 index = 0;
        
        for(std::vector<TW_IDENTITY>::iterator it = sources.begin(); it < sources.end(); it++)
        {
            TW_IDENTITY identity = *it;
            
            PA_ObjectRef device = PA_CreateObject();
            
            ob_set_s(device, L"manufacturer", (char *)identity.Manufacturer);
            ob_set_s(device, L"productFamily", (char *)identity.ProductFamily);
            ob_set_s(device, L"productName", (char *)identity.ProductName);

            ob_set_i(device, L"protocolMajor", identity.ProtocolMajor);
            ob_set_i(device, L"protocolMinor", identity.ProtocolMinor);
            ob_set_i(device, L"supportedGroups", identity.SupportedGroups);

            PA_ObjectRef version = PA_CreateObject();
            ob_set_s(version, L"info", (char *)identity.Version.Info);
            ob_set_i(version, L"majorNum", identity.Version.MajorNum);
            ob_set_i(version, L"minorNum", identity.Version.MinorNum);
            ob_set_i(version, L"language", identity.Version.Language);
            ob_set_i(version, L"country", identity.Version.Country);

            ob_set_o(device, L"version", version);
            
            PA_Variable d = PA_CreateVariable(eVK_Object);
            PA_SetObjectVariable(&d, device);
            
            PA_SetCollectionElement(devices, index++, d);
        }
        
        tw_ret = twain_dsm_close(&tw_identity, &tw_parent);
    }
    
    PA_ReturnCollection(params, devices);
}

void TWAIN_Get_default_option(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_scanner;
    Param1_scanner.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef option = PA_CreateObject();
    
	std::vector<uint8_t> data;
    
    TW_UINT16 majorNum, minorNum, language, country;
    twain_get_version_info(&majorNum, &minorNum, &language, &country);
    
#if VERSIONWIN
    
    std::wstring ParamA;
    std::wstring ParamB;
    
    twain_generate_uuid_pair(ParamA, ParamB);
    
    DWORD ParamA_len = 0;
    DWORD ParamB_len = 0;
    DWORD Param1_len = 0;
    DWORD Param2_len = 0;
    
    HANDLE scanEvent_p = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
                                     TRUE, /* creates a manual-reset event object */
                                     FALSE, /* initial state of the event object */
                                     ParamA.c_str());
    
    if(scanEvent_p)
    {
        CUTF8String Param2_option; /* not used */
        
        HANDLE fmIn = createFmIn1(Param1_scanner,
                                  Param2_option,
                                  ParamA,
                                  ParamB,
                                  &ParamA_len,
                                  &ParamB_len,
                                  &Param1_len,
                                  &Param2_len);
        if(fmIn)
        {
            twain_version_info_t version_info;
            version_info.majorNum = majorNum;
            version_info.minorNum = minorNum;
            version_info.language = language;
            version_info.country = country;
            
            HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
                                              0 /* stack size:default */,
                                              getOptionWin,
                                              &version_info /* arguments */,
                                              0 /* init flags:execute immediately */,
                                              NULL /* thread id */);
            if(h)
            {
                waitForEvent(h, scanEvent_p, data, ParamB, (sizeof(DWORD)*4) + ParamA_len + ParamB_len + Param1_len + Param2_len);
                
                CloseHandle(h);
            }//h
            
            CloseHandle(fmIn);
        }//fmIn
        CloseHandle(scanEvent_p);
    }//scanEvent_p
    
#else
    
    CUTF8String Param2_option; /* not used */
    
    getOption(Param1_scanner, Param2_option, data,
              majorNum, minorNum, language, country);
    
#endif
    
    uint32_t data_len = (uint32_t)data.size();
    size_t p = 0;
	C_TEXT t;
	PA_Unistring u;
	PA_Variable args[2];
	uint32_t len_1, len_2;

    if(sizeof(uint32_t) < data_len)
    {
        memcpy(&len_1, &data[p], sizeof(uint32_t));
        p += sizeof(uint32_t);
        
		if ((sizeof(uint32_t) + len_1) < data_len)
		{
			std::vector<char>buf(len_1);
			memcpy(&buf[0], &data[p], len_1);
			p += len_1;

			t.setUTF8String((const uint8_t *)&buf[0], len_1);
			u = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
			PA_SetStringVariable(&args[0], &u);
			PA_SetLongintVariable(&args[1], eVK_Object);
			ob_set_o(option, L"option", PA_GetObjectVariable(PA_ExecuteCommandByID(1218/*JSON Parse*/, args, 2)));
			PA_DisposeUnistring(&u);

			if ((sizeof(uint32_t) + len_1 + sizeof(uint32_t)) < data_len)
			{
				memcpy(&len_2, &data[p], sizeof(uint32_t));
				p += sizeof(uint32_t);

				if ((sizeof(uint32_t) + len_1 + sizeof(uint32_t) + len_2) == data_len)
				{
					buf.resize(len_2);
					memcpy(&buf[0], &data[p], len_2);
					p += len_2;

					t.setUTF8String((const uint8_t *)&buf[0], len_2);
					u = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
					PA_SetStringVariable(&args[0], &u);
					PA_SetLongintVariable(&args[1], eVK_Object);
					ob_set_o(option, L"values", PA_GetObjectVariable(PA_ExecuteCommandByID(1218/*JSON Parse*/, args, 2)));
					PA_DisposeUnistring(&u);
				}

			}

		}
   
    }
    
    PA_ReturnObject(params, option);
}

void TWAIN_SCAN(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
   
    C_TEXT Param1_scanner;
    Param1_scanner.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef option = PA_GetObjectParameter(params, 2);
	int format = PA_GetLongParameter(params, 3);

	TW_UINT16 majorNum, minorNum, language, country;
	twain_get_version_info(&majorNum, &minorNum, &language, &country);

    CUTF8String Param2_option;
    
    if (option) {
        ob_stringify(option, &Param2_option);
    }
    
	std::vector<uint8_t> data;

#if VERSIONWIN

	std::wstring ParamA;
	std::wstring ParamB;

	twain_generate_uuid_pair(ParamA, ParamB);

	DWORD ParamA_len = 0;
	DWORD ParamB_len = 0;
	DWORD Param1_len = 0;
	DWORD Param2_len = 0;

	HANDLE scanEvent_p = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
		TRUE, /* creates a manual-reset event object */
		FALSE, /* initial state of the event object */
		ParamA.c_str());

	if (scanEvent_p)
	{
		HANDLE fmIn = createFmIn1(Param1_scanner,
			Param2_option,
			ParamA,
			ParamB,
			&ParamA_len,
			&ParamB_len,
			&Param1_len,
			&Param2_len);
		if (fmIn)
		{
			twain_version_info_t version_info;
			version_info.majorNum = majorNum;
			version_info.minorNum = minorNum;
			version_info.language = language;
			version_info.country = country;
			version_info.format = format;

			HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
				0 /* stack size:default */,
				doScanWin,
				&version_info /* arguments */,
				0 /* init flags:execute immediately */,
				NULL /* thread id */);
			if (h)
			{
				waitForEvent(h, scanEvent_p, data, ParamB, (sizeof(DWORD) * 4) + ParamA_len + ParamB_len + Param1_len + Param2_len);

				CloseHandle(h);
			}//h

			CloseHandle(fmIn);
		}//fmIn
		CloseHandle(scanEvent_p);
	}//scanEvent_p

#else

	doScan(Param1_scanner,
		Param2_option,
		data,
		majorNum,
		minorNum,
		language,
		country,
		format);

#endif

	PA_CollectionRef images = PA_CreateCollection();
	PA_long32 i = 0;

	size_t data_len = data.size();
	unsigned char *p = (unsigned char *)&data[0];
	size_t totalsize = 0;

	while (totalsize<data_len)
	{
		size_t outbuffersize = 0;
		memcpy(&outbuffersize, p, sizeof(outbuffersize));
		p += sizeof(outbuffersize);

		std::vector<uint8_t>buf(outbuffersize);
		memcpy(&buf[0], p, outbuffersize);

		PA_Picture picture = PA_CreatePicture((void *)&buf[0], outbuffersize);
		PA_Variable v = PA_CreateVariable(eVK_Picture);
		PA_SetPictureVariable(&v, picture);
		PA_SetCollectionElement(images, i++, v);

		p += outbuffersize;
		totalsize += sizeof(outbuffersize);
		totalsize += outbuffersize;
	}

    PA_ReturnCollection(params, images);
}

#pragma mark Get Option

void getOption(
               C_TEXT& Param1_scanner,
               CUTF8String& Param2_option,
               std::vector<uint8_t>& data,
               TW_UINT16 majorNum,
               TW_UINT16 minorNum,
               TW_UINT16 language,
               TW_UINT16 country) {
    
    TW_IDENTITY tw_identity;
    TW_USERINTERFACE tw_userinterface;
    HWND tw_parent = NULL;
    
#if USE_TWAIN_DSM
    TW_ENTRYPOINT tw_entrypoint;
#else
    void *tw_entrypoint;
#endif
    
    twain_configure(&tw_identity,
                    &tw_userinterface,
                    &tw_entrypoint,
                    &tw_parent,
                    majorNum, minorNum, language, country);
    
    Json::Value json_scanner_options(Json::objectValue);
    Json::Value json_scanner_option_values(Json::objectValue);
    
    TW_UINT16 tw_ret = twain_dsm_open(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent);
    if(tw_ret == TWRC_SUCCESS)
    {
        TW_IDENTITY tw_source_identity;
        tw_ret = twain_source_open(&tw_identity, &tw_source_identity, Param1_scanner);
        
        if(tw_ret == TWRC_SUCCESS)
        {
            TW_CAPABILITY tw_capability;
            memset(&tw_capability, 0, sizeof(TW_CAPABILITY));
            
            tw_capability.Cap = CAP_SUPPORTEDCAPS;
            tw_capability.ConType = 0;
            tw_capability.hContainer = 0;
            
            if(TWRC_SUCCESS == DSM_Entry(
                                         &tw_identity,
                                         &tw_source_identity,
                                         DG_CONTROL,
                                         DAT_CAPABILITY,
                                         MSG_GET,
                                         (TW_MEMREF)&tw_capability))
            {
                if(tw_capability.ConType == TWON_ARRAY)
                {
                    std::vector<TW_UINT16>capabilities;
                    
                    pTW_ARRAY pARRAY = (pTW_ARRAY)DSM::Lock(&tw_entrypoint, tw_capability.hContainer);
                    
                    for (int i = 0; i < pARRAY->NumItems;++i)
                    {
                        /* important to downcast */
                        TW_UINT16 currentValue = ((pTW_UINT16)(&pARRAY->ItemList))[i];
                        if(currentValue != CAP_SUPPORTEDCAPS)
                        {
                            capabilities.push_back(currentValue);
                        }
                    }
                    
                    DSM::Unlock(&tw_entrypoint, tw_capability.hContainer);
                    DSM::Free(&tw_entrypoint, tw_capability.hContainer);
                    
                    for(std::vector<TW_UINT16>::iterator it = capabilities.begin(); it != capabilities.end(); ++it)
                    {
                        tw_capability.Cap = *it;

						twain_get_option_value(&tw_identity,
							&tw_source_identity,
							&tw_capability,
							&tw_entrypoint,
							json_scanner_options,
							json_scanner_option_values);

#if VERSIONMAC
                        PA_YieldAbsolute();
#endif
                    }
                }
            }
            tw_ret = twain_source_close(&tw_identity, &tw_source_identity);
        }
        tw_ret = twain_dsm_close(&tw_identity, &tw_parent);
    }
    
    uint32_t len_1, len_2;
    std::string json_1, json_2;
    
    Json::StreamWriterBuilder builder;
    
    json_1 = Json::writeString(builder, json_scanner_options);
    len_1 = (uint32_t)json_1.length();
    
    json_2 = Json::writeString(builder, json_scanner_option_values);
    len_2 = (uint32_t)json_2.length();
    
    data.resize(sizeof(uint32_t) + len_1 + sizeof(uint32_t) + len_2);
    
    memcpy((void *)&data[0], (const void *)&len_1, sizeof(uint32_t));
    memcpy((void *)&data[sizeof(uint32_t)], (const void *)json_1.c_str(), len_1);
    
    memcpy((void *)&data[sizeof(uint32_t) + len_1], (const void *)&len_2, sizeof(uint32_t));
    memcpy((void *)&data[sizeof(uint32_t) + len_1 + sizeof(uint32_t)], (const void *)json_2.c_str(), len_2);
    
}

#if VERSIONWIN

unsigned __stdcall getOptionWin(void *p) {
    
    twain_version_info_t *version_info_p = (twain_version_info_t *)p;
    
	std::vector<uint8_t>data;
    
    DWORD ParamA_len, ParamB_len, Param1_len, Param2_len;
    HANDLE fmIn = createFmIn2(&ParamA_len, &ParamB_len, &Param1_len, &Param2_len);
    
    if (fmIn)
    {
        DWORD len = (sizeof(DWORD)*4) + ParamA_len + ParamB_len + Param1_len + Param2_len;
        
        LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
        
        if (bufIn)
        {
            std::wstring ParamA;
            std::wstring ParamB;
            
            C_TEXT Param1_scanner;
			CUTF8String Param2_option;
            
            HANDLE scanEvent_c = createEventforBufIn2(bufIn,
                                                      ParamA_len, ParamB_len,
                                                      Param1_len, Param2_len,
                                                      ParamA, ParamB, Param1_scanner, Param2_option);
            if (scanEvent_c)
            {
                
                /* do stuff and poluate data */
                
                getOption(Param1_scanner,
                          Param2_option, /* not used here */
                          data, /* return value */
                          version_info_p->majorNum,
                          version_info_p->minorNum,
                          version_info_p->language,
                          version_info_p->country);
                
                /* stuff done */
                
                HANDLE fmOut = createFmOut2(data);
                
                if (fmOut)
                {
                    /* tell p that the response is ready */
                    HANDLE scanEvent_p = OpenEvent(EVENT_ALL_ACCESS,
                                                   FALSE, /* processes created by this process do not inherit this handle */
                                                   ParamA.c_str());
                    if (scanEvent_p)
                    {
                        SetEvent(scanEvent_p);
                        CloseHandle(scanEvent_p);
                    }
                    
                    /* wait for p to set scanEvent_c */
                    WaitForSingleObject(scanEvent_c, INFINITE);
                    ResetEvent(scanEvent_c);
                    /* now ready to die */
                    
                    CloseHandle(fmOut);
                }//fmOut
                CloseHandle(scanEvent_c);
            }//scanEvent_c
            UnmapViewOfFile(bufIn);
        }//bufIn
        CloseHandle(fmIn);
    }
    
    _endthreadex(0);
    return 0;
}

#endif

#pragma mark Scan

void doScan(C_TEXT &Param1_scanner,
	CUTF8String& Param2_option,
	std::vector<uint8_t>& picture,
	TW_UINT16 majorNum,
	TW_UINT16 minorNum,
	TW_UINT16 language,
	TW_UINT16 country,
	int Param3_format)
{
	Json::Value root;
	Json::CharReaderBuilder builder;
	std::string errors;

	Json::CharReader *reader = builder.newCharReader();
	bool parse = reader->parse((const char *)Param2_option.c_str(),
		(const char *)Param2_option.c_str() + Param2_option.size(),
		&root,
		&errors);
	delete reader;

	TW_IDENTITY tw_identity;
	TW_USERINTERFACE tw_userinterface;
	HWND tw_parent = NULL;

#if USE_TWAIN_DSM
	TW_ENTRYPOINT tw_entrypoint;
#else
	void *tw_entrypoint;
#endif

	twain_configure(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent, majorNum, minorNum, language, country);

	TW_UINT16 tw_ret = twain_dsm_open(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent);
	if (tw_ret == TWRC_SUCCESS)
	{
		TW_IDENTITY tw_source_identity;
		tw_ret = twain_source_open(&tw_identity, &tw_source_identity, Param1_scanner);

		if (tw_ret == TWRC_SUCCESS)
		{
			if (parse)
			{
				if (root.isObject())
				{
					for (Json::Value::const_iterator it = root.begin(); it != root.end(); it++)
					{
						Json::Value key = it.key();
						JSONCPP_STRING name = it.name();

						Json::Value value = *it;

						TW_UINT16 cap = twain_get_cap(name);

						if (cap)
						{
							TW_CAPABILITY tw_capability;
							memset(&tw_capability, 0, sizeof(TW_CAPABILITY));

							tw_capability.Cap = cap;
							tw_capability.ConType = 0;
							tw_capability.hContainer = 0;

							/* find value type */

							if (TWRC_SUCCESS == DSM_Entry(
								&tw_identity,
								&tw_source_identity,
								DG_CONTROL,
								DAT_CAPABILITY,
								MSG_GET,
								(TW_MEMREF)&tw_capability))
							{
								TW_UINT16 itemType = 0;
								TW_UINT32 numItems = 0;
								TW_UINT32 contSize = 0;

								void *_p = DSM::Lock(&tw_entrypoint, tw_capability.hContainer);

								switch (tw_capability.ConType)
								{
								case TWON_ARRAY:

									break;
								case TWON_ENUMERATION:
									itemType = ((pTW_ENUMERATION)_p)->ItemType;
									numItems = ((pTW_ENUMERATION)_p)->NumItems;
									contSize = sizeof(TW_ENUMERATION) + (getSizeForItemType(itemType) * numItems);
									break;
								case TWON_ONEVALUE:
									itemType = ((pTW_ONEVALUE)_p)->ItemType;
									contSize = sizeof(TW_ONEVALUE);
									break;
								case TWON_RANGE:
									itemType = ((pTW_RANGE)_p)->ItemType;
									contSize = sizeof(TW_RANGE);
									break;
								}

								DSM::Unlock(&tw_entrypoint, tw_capability.hContainer);
								DSM::Free(&tw_entrypoint, tw_capability.hContainer);

								if (contSize)
								{
									tw_capability.hContainer = DSM::Alloc(&tw_entrypoint, contSize);

									void *p = DSM::Lock(&tw_entrypoint, tw_capability.hContainer);

									switch (tw_capability.ConType)
									{
									case TWON_ARRAY:

										break;
									case TWON_ENUMERATION:
										((pTW_ENUMERATION)p)->ItemType = itemType;
										((pTW_ENUMERATION)p)->NumItems = numItems;
										break;
									case TWON_ONEVALUE:
										((pTW_ONEVALUE)p)->ItemType = itemType;
										break;
									case TWON_RANGE:
										((pTW_RANGE)p)->ItemType = itemType;
										break;
									}

									pTW_ENUMERATION pENUMERATION = (pTW_ENUMERATION)p;
									pTW_ONEVALUE pONEVALUE = (pTW_ONEVALUE)p;
									pTW_RANGE pRANGE = (pTW_RANGE)p;

									double f_value = 0.0f;
									if (value.isDouble()) {
										f_value = value.asDouble();
									}

									TW_BOOL b_value = false;
									if (value.isBool()) {
										b_value = value.asBool();
									}

									int i_value = json_get_cap_constant(value, cap);

									switch (tw_capability.ConType)
									{
									case TWON_ARRAY:

										break;

									case TWON_ENUMERATION:
										for (int i = 0; i < pENUMERATION->NumItems; ++i)
										{
											if (i_value == (pENUMERATION->ItemList)[i])
											{
												pENUMERATION->CurrentIndex = i;
												break;
											}
										}
										break;

									case TWON_ONEVALUE:
										switch (pONEVALUE->ItemType)
										{
										case TWTY_FIX32:
										{
											TW_INT32 value = (TW_INT32)(f_value * 65536.0 + ((f_value < 0) ? (-0.5) : 0.5));
											TW_FIX32 tw_fix32;
											tw_fix32.Whole = (TW_UINT16)(value >> 16);
											tw_fix32.Frac = (TW_UINT16)(value & 0x0000ffffL);
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_fix32, sizeof(TW_FIX32));
										}
										break;
										case TWTY_FRAME:
										{
											//not implemented!
										}
										break;
										case TWTY_INT8:
										{
											TW_INT8 tw_int8 = (TW_INT8)i_value;
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_int8, sizeof(TW_INT8));
										}
										break;
										case TWTY_INT16:
										{
											TW_INT16 tw_int16 = (TW_INT16)i_value;
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_int16, sizeof(TW_INT16));
										}
										break;
										case TWTY_INT32:
										{
											TW_INT32 tw_int32 = (TW_INT32)i_value;
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_int32, sizeof(TW_INT32));
										}
										break;
										case TWTY_UINT8:
										{
											TW_UINT8 tw_uint8 = (TW_UINT8)i_value;
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_uint8, sizeof(TW_UINT8));
										}
										break;
										case TWTY_UINT16:
										{
											TW_UINT16 tw_uint16 = (TW_UINT16)i_value;
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_uint16, sizeof(TW_UINT16));
										}
										break;
										case TWTY_UINT32:
										{
											TW_UINT32 tw_uint32 = (TW_UINT32)i_value;
											memcpy((void *)&pONEVALUE->Item, (const void *)&tw_uint32, sizeof(TW_UINT32));
										}
										break;
										case TWTY_BOOL:
										{
											memcpy((void *)&pONEVALUE->Item, (const void *)&b_value, sizeof(TW_BOOL));
										}
										break;
										case TWTY_STR32:
										case TWTY_STR64:
										case TWTY_STR128:
										case TWTY_STR255:
										{

										}
										break;
										//					case TWTY_STR1024:
										//					case TWTY_UNI512:
										//						break;
										default:
											break;
										}
										break;

									case TWON_RANGE:
										switch (((pTW_RANGE)&tw_capability)->ItemType)
										{
										case TWTY_FIX32:
										{
											TW_INT32 value = (TW_INT32)(f_value * 65536.0 + ((f_value < 0) ? (-0.5) : 0.5));
											TW_FIX32 tw_fix32;
											tw_fix32.Whole = (TW_UINT16)(value >> 16);
											tw_fix32.Frac = (TW_UINT16)(value & 0x0000ffffL);
											memcpy((void *)&((pTW_RANGE)&tw_capability)->CurrentValue, (const void *)&tw_fix32, sizeof(TW_FIX32));
										}
										break;
										case TWTY_FRAME:
										{
											//not implemented!
										}
										break;
										case TWTY_INT8:
										{
											TW_INT8 tw_int8 = (TW_INT8)i_value;
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_int8, sizeof(TW_INT8));
										}
										break;
										case TWTY_INT16:
										{
											TW_INT16 tw_int16 = (TW_INT16)i_value;
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_int16, sizeof(TW_INT16));
										}
										break;
										case TWTY_INT32:
										{
											TW_INT32 tw_int32 = (TW_INT32)i_value;
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_int32, sizeof(TW_INT32));
										}
										break;
										case TWTY_UINT8:
										{
											TW_UINT8 tw_uint8 = (TW_UINT8)i_value;
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_uint8, sizeof(TW_UINT8));
										}
										break;
										case TWTY_UINT16:
										{
											TW_UINT16 tw_uint16 = (TW_UINT16)i_value;
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_uint16, sizeof(TW_UINT16));
										}
										break;
										case TWTY_UINT32:
										{
											TW_UINT32 tw_uint32 = (TW_UINT32)i_value;
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_uint32, sizeof(TW_UINT32));
										}
										break;
										case TWTY_BOOL:
										{
											memcpy((void *)&pRANGE->CurrentValue, (const void *)&b_value, sizeof(TW_BOOL));
										}
										break;
										case TWTY_STR32:
										case TWTY_STR64:
										case TWTY_STR128:
										case TWTY_STR255:
										{

										}
										break;
										//					case TWTY_STR1024:
										//					case TWTY_UNI512:
										//						break;
										default:
											break;
										}
										break;

									}

									if (TWRC_SUCCESS == DSM_Entry(
										&tw_identity,
										&tw_source_identity,
										DG_CONTROL,
										DAT_CAPABILITY,
										MSG_SET,
										(TW_MEMREF)&tw_capability))
									{

									}
									DSM::Unlock(&tw_entrypoint, tw_capability.hContainer);
									DSM::Free(&tw_entrypoint, tw_capability.hContainer);
								}

							}

						}

					}

				}

			}

			tw_ret = twain_source_enable(&tw_identity, &tw_source_identity, &tw_userinterface);

			if (tw_ret == TWRC_SUCCESS)
			{
				TW_EVENT tw_event;
				memset(&tw_event, 0, sizeof(TW_EVENT));

				//timeout to avoid freeze
				time_t now = time(NULL);
				time_t end = now + TWAIN_PROCESS_EVENT_TIMEOUT;

				tw_ret = TWRC_NOTDSEVENT;
				while ((tw_ret == TWRC_NOTDSEVENT) && (time(NULL) < end))
				{
					tw_ret = DSM_Entry(
						&tw_identity,
						&tw_source_identity,
						DG_CONTROL,
						DAT_EVENT,
						MSG_PROCESSEVENT,
						(TW_MEMREF)&tw_event);
				}
				if (TWRC_DSEVENT == tw_ret)
				{
					if (MSG_XFERREADY == tw_event.TWMessage)
					{
						//scan context
						TW_SETUPMEMXFER tw_setup_mem_xfer;
						TW_IMAGEMEMXFER tw_image_mem_xfer;
						TW_IMAGEMEMXFER image_mem_xfer_template;
						TW_IMAGEINFO tw_imageinfo;

						int dpi_x;
						int dpi_y;
						int depth;
						int lines;
						int accumulated_lines;
						int accumulated_bytes;
						int pixels_per_line;
						int bytes_per_line;
						J_COLOR_SPACE jpg_color_space;
						int png_color_type;

						bool pending_xfers = true;

						while (pending_xfers)
						{
#if VERSIONMAC
							PA_YieldAbsolute();
#endif
							C_BLOB data, image;
							//reset for each image
							memset(&tw_imageinfo, 0, sizeof(TW_IMAGEINFO));

							tw_ret = DSM_Entry(
								&tw_identity,
								&tw_source_identity,
								DG_IMAGE,
								DAT_IMAGEINFO,
								MSG_GET,
								(TW_MEMREF)&tw_imageinfo);

							if (tw_ret == TWRC_SUCCESS)
							{
								dpi_x = tw_imageinfo.XResolution.Whole;
								dpi_y = tw_imageinfo.YResolution.Whole;
								depth = tw_imageinfo.BitsPerPixel;
								lines = tw_imageinfo.ImageLength;

								accumulated_lines = 0;//in case lines = -1
								accumulated_bytes = 0;//for debug
								pixels_per_line = tw_imageinfo.ImageWidth;
								bytes_per_line = (((tw_imageinfo.ImageWidth * tw_imageinfo.BitsPerPixel) + 7) / 8);

								switch (tw_imageinfo.PixelType)
								{
								case TWPT_BW:
								case TWPT_GRAY:
									jpg_color_space = JCS_GRAYSCALE;
									png_color_type = PNG_COLOR_TYPE_GRAY;
									depth = tw_imageinfo.BitsPerPixel;
									break;
								case TWPT_RGB:
									jpg_color_space = JCS_RGB;
									png_color_type = PNG_COLOR_TYPE_RGB;
									depth = tw_imageinfo.BitsPerPixel / 3;
									break;
								default:
									//maybe later...
									//#define TWPT_BW
									//#define TWPT_GRAY
									//#define TWPT_RGB
									//#define TWPT_PALETTE
									//#define TWPT_CMY
									//#define TWPT_CMYK
									//#define TWPT_YUV
									//#define TWPT_YUVK
									//#define TWPT_CIEXYZ
									jpg_color_space = JCS_UNKNOWN;
									png_color_type = PNG_COLOR_TYPE_UNKNOWN;
									break;
								}

								bool incremental_image_generation = false;
								//incremental_image_generation not supported

								memset(&tw_setup_mem_xfer, 0, sizeof(TW_SETUPMEMXFER));

								tw_ret = DSM_Entry(
									&tw_identity,
									&tw_source_identity,
									DG_CONTROL,
									DAT_SETUPMEMXFER,
									MSG_GET,
									(TW_MEMREF)&tw_setup_mem_xfer);

								if (tw_ret == TWRC_SUCCESS)
								{
									//setup buffer
									memset(&image_mem_xfer_template, 0, sizeof(TW_IMAGEMEMXFER));
									image_mem_xfer_template.Compression = TWON_DONTCARE16;
									image_mem_xfer_template.BytesPerRow = TWON_DONTCARE32;
									image_mem_xfer_template.Columns = TWON_DONTCARE32;
									image_mem_xfer_template.Rows = TWON_DONTCARE32;
									image_mem_xfer_template.XOffset = TWON_DONTCARE32;
									image_mem_xfer_template.YOffset = TWON_DONTCARE32;
									image_mem_xfer_template.BytesWritten = TWON_DONTCARE32;
									image_mem_xfer_template.Memory.Flags = TWMF_APPOWNS | TWMF_POINTER;
									image_mem_xfer_template.Memory.Length = tw_setup_mem_xfer.Preferred;

									TW_HANDLE hMem = (TW_HANDLE)DSM::Alloc(&tw_entrypoint, tw_setup_mem_xfer.Preferred);

									if (!hMem) break;//(while)

									image_mem_xfer_template.Memory.TheMem = DSM::Lock(&tw_entrypoint, hMem);

									bool scan_started = false;
									//this is the real buffer
									memset(&tw_image_mem_xfer, 0, sizeof(TW_IMAGEMEMXFER));

									for (;;)
									{
										memcpy(&tw_image_mem_xfer, &image_mem_xfer_template, sizeof(TW_IMAGEMEMXFER));
										memset(tw_image_mem_xfer.Memory.TheMem, 0, tw_image_mem_xfer.Memory.Length);

										tw_ret = DSM_Entry(
											&tw_identity,
											&tw_source_identity,
											DG_IMAGE,
											DAT_IMAGEMEMXFER,
											MSG_GET,
											(TW_MEMREF)&tw_image_mem_xfer);

										if ((tw_ret == TWRC_SUCCESS) || (tw_ret == TWRC_XFERDONE))
										{
											accumulated_lines += tw_image_mem_xfer.Rows;
											accumulated_bytes = tw_image_mem_xfer.BytesWritten;

											if (!scan_started)
											{
												//start of image
												scan_started = true;
											}//!scan_started

											if (tw_image_mem_xfer.Memory.Length)
											{
												const uint8_t *p = reinterpret_cast<const uint8_t *>(tw_image_mem_xfer.Memory.TheMem);
												data.addBytes(p, tw_image_mem_xfer.BytesWritten);
											}
											if (tw_ret == TWRC_XFERDONE)
											{
												if (lines == -1)
												{
													lines = accumulated_lines;
												}

												pixels_per_line = tw_image_mem_xfer.Columns;
												bytes_per_line = tw_image_mem_xfer.BytesPerRow;

												int logical_size = tw_image_mem_xfer.BytesPerRow * lines;
												int actual_size = data.getBytesLength();

												if (logical_size > actual_size)
												{
													int padding = logical_size - actual_size;
													std::vector<uint8_t>buf(padding);
													memset(&buf[0], 0xFF, padding);
													data.addBytes(&buf[0], padding);
												}
												if ((jpg_color_space == JCS_GRAYSCALE) || (jpg_color_space = JCS_RGB))
												{
													switch (Param3_format)
													{
													case 2:
													{
														png_write_blob(
															data, image,
															pixels_per_line,
															lines,
															depth,
															bytes_per_line,
															png_color_type,
															dpi_x,
															dpi_y);
													}
													break;
													default:
													{
														jpg_write_blob(
															data, image,
															pixels_per_line,
															lines,
															depth,
															bytes_per_line,
															jpg_color_space,
															dpi_x,
															dpi_y);
														picture.resize(image.getBytesLength());
													}
													break;

													}//switch

													memcpy((void *)&picture[0], (const void *)image.getBytesPtr(), picture.size());
												}
												break;//for()

											}
											else if ((tw_ret == TWRC_CANCEL) || (tw_ret == TWRC_FAILURE))
											{
												break;//for()
											}
										}

									}//for

									DSM::Unlock(&tw_entrypoint, hMem);
									DSM::Free(&tw_entrypoint, hMem);

									if (TWRC_XFERDONE != tw_ret) break;//while()

																	   //update pending_xfers
									TW_PENDINGXFERS tw_pendingxfers;
									memset(&tw_pendingxfers, 0, sizeof(TW_PENDINGXFERS));

									tw_ret = DSM_Entry(
										&tw_identity,
										&tw_source_identity,
										DG_CONTROL,
										DAT_PENDINGXFERS,
										MSG_ENDXFER,
										(TW_MEMREF)&tw_pendingxfers);

									if (TWRC_SUCCESS == tw_ret)
									{
										if (0 == tw_pendingxfers.Count)
										{
											pending_xfers = false;//no more images
										}//else more images
									}
									else
									{
										pending_xfers = false;//aborted
									}

								}
								else
								{
									break;//(while)
								}
							}
							else
							{
								break;//(while)
							}

						}//while

						if (pending_xfers == true)//broken from while loop
						{
							TW_PENDINGXFERS tw_pendxfers;
							memset(&tw_pendxfers, 0, sizeof(TW_PENDINGXFERS));
							DSM_Entry(
								&tw_identity,
								0,
								DG_CONTROL,
								DAT_PENDINGXFERS,
								MSG_ENDXFER,
								(TW_MEMREF)&tw_pendxfers);
							if (0 != tw_pendxfers.Count)
							{
								memset(&tw_pendxfers, 0, sizeof(TW_PENDINGXFERS));
								DSM_Entry(
									&tw_identity,
									0,
									DG_CONTROL,
									DAT_PENDINGXFERS,
									MSG_RESET,
									(TW_MEMREF)&tw_pendxfers);
							}
						}
					}
				}

				tw_ret = twain_source_disable(&tw_identity, &tw_source_identity, &tw_userinterface);
			}
			tw_ret = twain_source_close(&tw_identity, &tw_source_identity);
		}

		tw_ret = twain_dsm_close(&tw_identity, &tw_parent);
	}

}

#if VERSIONWIN
unsigned __stdcall doScanWin(void *p)
{
	twain_version_info_t *version_info_p = (twain_version_info_t *)p;

	std::vector<uint8_t> data;

	int Param3_format = version_info_p->format;

	DWORD ParamA_len, ParamB_len, Param1_len, Param2_len;
	HANDLE fmIn = createFmIn2(&ParamA_len, &ParamB_len, &Param1_len, &Param2_len);

	if (fmIn)
	{
		DWORD len = (sizeof(DWORD) * 4) + ParamA_len + ParamB_len + Param1_len + Param2_len;

		LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);

		if (bufIn)
		{
			std::wstring ParamA;
			std::wstring ParamB;

			C_TEXT Param1_scanner;
			CUTF8String Param2_option;

			HANDLE scanEvent_c = createEventforBufIn2(bufIn,
				ParamA_len, ParamB_len,
				Param1_len, Param2_len,
				ParamA, ParamB, Param1_scanner, Param2_option);
			if (scanEvent_c)
			{

				/* do stuff and poluate data */

				doScan(Param1_scanner,
					Param2_option, data, /* return value */
					version_info_p->majorNum,
					version_info_p->minorNum,
					version_info_p->language,
					version_info_p->country,
					Param3_format);

				/* stuff done */

				HANDLE fmOut = createFmOut2(data);

				if (fmOut)
				{
					/* tell p that the response is ready */
					HANDLE scanEvent_p = OpenEvent(EVENT_ALL_ACCESS,
						FALSE, /* processes created by this process do not inherit this handle */
						ParamA.c_str());
					if (scanEvent_p)
					{
						SetEvent(scanEvent_p);
						CloseHandle(scanEvent_p);
					}

					/* wait for p to set scanEvent_c */
					WaitForSingleObject(scanEvent_c, INFINITE);
					ResetEvent(scanEvent_c);
					/* now ready to die */

					CloseHandle(fmOut);
				}//fmOut
				CloseHandle(scanEvent_c);
			}//scanEvent_c
			UnmapViewOfFile(bufIn);
		}//bufIn
		CloseHandle(fmIn);
	}

	_endthreadex(0);
	return 0;
}

#endif
